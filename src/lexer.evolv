// src/lexer.evolv

import "utils/string_utils.evolv";

// Define token types
enum TokenType {
    IDENTIFIER,
    NUMBER,
    KEYWORD,
    OPERATOR,
    STRING,
    EOF,
    ERROR
}

// Define a Token class to represent individual tokens
class Token {
    var type;
    var value;

    function initialize(type, value) {
        this.type = type;
        this.value = value;
    }
}

// The Lexer class will convert source code into tokens
class Lexer {
    private var input;
    private var position;
    private var currentChar;

    function initialize(sourceCode) {
        input = sourceCode;
        position = 0;
        currentChar = input[position];
    }

    // Returns the next token from the source code
    function next() -> Token {
        while (currentChar != null) {
            if (isWhitespace(currentChar)) {
                skipWhitespace();
                continue;
            }
            if (isLetter(currentChar)) {
                return identifierOrKeyword();
            }
            if (isDigit(currentChar)) {
                return number();
            }
            if (currentChar == '"') {
                return string();
            }
            if (currentChar == '+' || currentChar == '-' || currentChar == '*' || currentChar == '/') {
                return operator();
            }
            if (currentChar == ';' || currentChar == '=' || currentChar == '(' || currentChar == ')') {
                return singleCharOperator();
            }
            return new Token(TokenType.ERROR, "Unexpected character: " + currentChar);
        }
        return new Token(TokenType.EOF, null);
    }

    // Check if the current character is a whitespace
    private function isWhitespace(char) -> bool {
        return char == ' ' || char == '\t' || char == '\n' || char == '\r';
    }

    // Skip whitespace characters
    private function skipWhitespace() {
        while (isWhitespace(currentChar)) {
            advance();
        }
    }

    // Check if the current character is a letter
    private function isLetter(char) -> bool {
        return (char >= 'a' && char <= 'z') || (char >= 'A' && char <= 'Z');
    }

    // Check if the current character is a digit
    private function isDigit(char) -> bool {
        return char >= '0' && char <= '9';
    }

    // Tokenize identifiers or keywords
    private function identifierOrKeyword() -> Token {
        var value = "";
        while (isLetter(currentChar) || isDigit(currentChar)) {
            value += currentChar;
            advance();
        }
        if (value == "var" || value == "function" || value == "if" || value == "else") {
            return new Token(TokenType.KEYWORD, value);
        }
        return new Token(TokenType.IDENTIFIER, value);
    }

    // Tokenize numbers
    private function number() -> Token {
        var value = "";
        while (isDigit(currentChar)) {
            value += currentChar;
            advance();
        }
        return new Token(TokenType.NUMBER, value);
    }

    // Tokenize strings
    private function string() -> Token {
        advance(); // Skip opening quote
        var value = "";
        while (currentChar != '"') {
            if (currentChar == null) {
                return new Token(TokenType.ERROR, "Unterminated string literal");
            }
            value += currentChar;
            advance();
        }
        advance(); // Skip closing quote
        return new Token(TokenType.STRING, value);
    }

    // Tokenize operators like +, -, *, /
    private function operator() -> Token {
        var value = currentChar;
        advance();
        return new Token(TokenType.OPERATOR, value);
    }

    // Tokenize single-character operators and delimiters like ;, =, (, )
    private function singleCharOperator() -> Token {
        var value = currentChar;
        advance();
        return new Token(TokenType.OPERATOR, value);
    }

    // Advance to the next character in the input
    private function advance() {
        position += 1;
        if (position >= input.length()) {
            currentChar = null;
        } else {
            currentChar = input[position];
        }
    }
}
